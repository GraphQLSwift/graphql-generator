import Foundation
import GraphQL

/// Generates Swift type definitions from GraphQL types
package struct TypeGenerator {
    let nameGenerator: SafeNameGenerator = .idiomatic

    package func generate(schema: GraphQLSchema) throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        """

        // Generate ResolversProtocol
        output += """

        public protocol ResolversProtocol: Sendable {
        """
        if schema.queryType != nil {
            output += """

                associatedtype Query: QueryProtocol
            """
        }
        if schema.mutationType != nil {
            output += """

                associatedtype Mutation: MutationProtocol
            """
        }
        if schema.subscriptionType != nil {
            output += """

                associatedtype Subscription: SubscriptionProtocol
            """
        }
        output += """

        }
        """

        // Ignore any internal types (which have prefix "__")
        let types = schema.typeMap.values.filter {
            !$0.name.hasPrefix("__")
        }

        // Generate Enum types
        let enumTypes = types.compactMap {
            $0 as? GraphQLEnumType
        }
        for type in enumTypes {
            output += """

            \(try generateEnum(for: type))
            """
        }

        // Generate Input types
        let inputTypes = types.compactMap {
            $0 as? GraphQLInputObjectType
        }
        for type in inputTypes {
            output += """

            \(try generateInputStruct(for: type))
            """
        }

        // Generate Union types
        var unionTypeMap = [String: [GraphQLUnionType]]()
        let unionTypes = types.compactMap {
            $0 as? GraphQLUnionType
        }
        for type in unionTypes {
            // Unions are represented by a marker protocol, with associated types conforming

            // Add description if available
            if let description = type.description {
                output += """

                /// \(description)
                """
            }
            let swiftTypeName = try swiftTypeDeclaration(for: type, nameGenerator: nameGenerator)
            output += """

            public protocol \(swiftTypeName): Sendable {}
            """

            // Record which types need to be conformed
            for conformingType in try type.types() {
                if unionTypeMap[conformingType.name] != nil {
                    unionTypeMap[conformingType.name]!.append(type)
                } else {
                    unionTypeMap[conformingType.name] = [type]
                }
            }
        }

        // Generate Interface types
        let interfaceTypes = types.compactMap {
            $0 as? GraphQLInterfaceType
        }
        for type in interfaceTypes {
            output += """

            \(try generateInterfaceProtocol(for: type))
            """
        }

        // Generate Object types (excluding Query, Mutation, Subscription)
        let objectTypes = types.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip root operation types
            $0.name != "Query" &&
            $0.name != "Mutation" &&
            $0.name != "Subscription"
        }
        for type in objectTypes {
            output += """

            \(try generateTypeProtocol(for: type, unionTypeMap: unionTypeMap))
            """
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += """

            \(try generateRootTypeProtocol(for: queryType))
            """
        }

        // Generate Mutation type
        if let mutationType = schema.mutationType {
            output += """

            \(try generateRootTypeProtocol(for: mutationType))
            """
        }

        // Generate Mutation type
        if let subscriptionType = schema.subscriptionType {
            output += """

            \(try generateRootTypeProtocol(for: subscriptionType))
            """
        }

        return output
    }

    func generateEnum(for type: GraphQLEnumType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            /// \(description)
            """
        }

        let swiftTypeName = try swiftTypeDeclaration(for: type, nameGenerator: nameGenerator)
        output += """

        public enum \(swiftTypeName): String, Codable, Sendable {
        """

        // Generate cases
        for value in type.values {
            if let description = value.description {
                output += """

                    /// \(description)
                """
            }
            // Use safe name generator for case names
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += """

                case \(safeCaseName) = "\(value.name)"
            """
        }

        output += """

        }
        """

        return output
    }


    func generateInputStruct(for type: GraphQLInputObjectType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            /// \(description)
            """
        }

        let swiftTypeName = try swiftTypeDeclaration(for: type, nameGenerator: nameGenerator)
        output += "public struct \(swiftTypeName): Codable, Sendable {\n"

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    /// \(description)
                """
            }

            let returnType = try swiftTypeReference(for: field.type, nameGenerator: nameGenerator)

            output += """

                public let \(nameGenerator.swiftMemberName(for: fieldName)): \(returnType)
            """
        }

        // Swift auto-generates memberwise initializers for structs, so we don't need to generate one
        output += """

        }
        """

        return output
    }

    func generateInterfaceProtocol(for type: GraphQLInterfaceType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            /// \(description)
            """
        }

        let interfaces = try type.interfaces().map {
            try swiftTypeDeclaration(for: $0, nameGenerator: nameGenerator)+", "
        }.joined(separator: "")

        let swiftTypeName = try swiftTypeDeclaration(for: type, nameGenerator: nameGenerator)
        output += """

        public protocol \(swiftTypeName): \(interfaces)Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    /// \(description)
                """
            }

            let returnType = try swiftTypeReference(for: field.type, nameGenerator: nameGenerator)

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeReference(for: arg.type, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: Context")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += """

                func \(nameGenerator.swiftMemberName(for: fieldName))(\(paramString)) async throws -> \(returnType)

            """
        }

        output += """

        }
        """

        return output
    }

    func generateTypeProtocol(for type: GraphQLObjectType, unionTypeMap: [String: [GraphQLUnionType]]) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            /// \(description)
            """
        }

        let unions = try unionTypeMap[type.name]?.map {
            try swiftTypeDeclaration(for: $0, nameGenerator: nameGenerator)+", "
        }.joined(separator: "") ?? ""

        let interfaces = try type.interfaces().map {
            try swiftTypeDeclaration(for: $0, nameGenerator: nameGenerator)+", "
        }.joined(separator: "")

        let swiftTypeName = try swiftTypeDeclaration(for: type, nameGenerator: nameGenerator)
        output += """

        public protocol \(swiftTypeName): \(unions)\(interfaces)Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    /// \(description)
                """
            }

            let returnType = try swiftTypeReference(for: field.type, nameGenerator: nameGenerator)

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeReference(for: arg.type, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: Context")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += """

                func \(nameGenerator.swiftMemberName(for: fieldName))(\(paramString)) async throws -> \(returnType)

            """
        }

        output += """

        }
        """

        return output
    }

    /// Root types are the same as normal types, except that their functions are static and they cannot
    /// inherit from interfaces or unions
    func generateRootTypeProtocol(for type: GraphQLObjectType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            /// \(description)
            """
        }

        let swiftTypeName = try swiftTypeDeclaration(for: type, nameGenerator: nameGenerator)
        output += """

        public protocol \(swiftTypeName): Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    /// \(description)
                """
            }

            var returnType = try swiftTypeReference(for: field.type, nameGenerator: nameGenerator)
            if type.name == "Subscription" {
                returnType = "AnyAsyncSequence<\(returnType)>"
            }

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeReference(for: arg.type, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: Context")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += """

                static func \(nameGenerator.swiftMemberName(for: fieldName))(\(paramString)) async throws -> \(returnType)

            """
        }

        output += """

        }
        """

        return output
    }
}

package enum GeneratorError: Error, CustomStringConvertible {
    case unsupportedType(String)

    package var description: String {
        switch self {
        case .unsupportedType(let message):
            return "Unsupported type: \(message)"
        }
    }
}
