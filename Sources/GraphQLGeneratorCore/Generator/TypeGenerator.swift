import Foundation
import GraphQL

/// Generates Swift type definitions from GraphQL types
package struct TypeGenerator {
    let nameGenerator: SafeNameGenerator = .idiomatic

    package func generate(schema: GraphQLSchema) throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation

        """

        // Generate struct for each object type (excluding Query, Mutation, Subscription)
        let typeMap = schema.typeMap
        let objectTypes = typeMap.values.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip introspection types and root operation types
            !$0.name.hasPrefix("__") &&
            $0.name != "Query" &&
            $0.name != "Mutation" &&
            $0.name != "Subscription"
        }
        for objectType in objectTypes {
            output += "\n"
            output += try generateTypeProtocol(for: objectType)
        }

        // Generate enums
        let enumTypes = typeMap.values.compactMap { $0 as? GraphQLEnumType }
        for enumType in enumTypes {
            // Skip GraphQL internal enums (prefixed with __)
            if enumType.name.hasPrefix("__") {
                continue
            }

            output += "\n"
            output += try generateEnum(for: enumType)
        }

        return output
    }

    func generateTypeProtocol(for type: GraphQLObjectType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += "/// \(description)\n"
        }

        // Use safe name generator for type name
        let safeTypeName = nameGenerator.swiftTypeName(for: type.name)
        output += "public protocol \(safeTypeName)Protocol: Sendable {\n"

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += "    /// \(description)\n"
            }

            let returnType = try swiftTypeName(for: field.type, nameGenerator: nameGenerator)

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeName(for: arg.type, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: ResolverContext")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += "    public func \(fieldName.lowercased())(\(paramString)) async throws -> \(returnType)\n\n"
        }

        // Swift auto-generates memberwise initializers for structs, so we don't need to generate one
        output += "}\n"

        return output
    }

    func generateEnum(for type: GraphQLEnumType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += "/// \(description)\n"
        }

        // Use safe name generator for enum name
        let safeEnumName = nameGenerator.swiftTypeName(for: type.name)
        output += "public enum \(safeEnumName): String, Codable, Sendable {\n"

        // Generate cases
        for value in type.values {
            if let description = value.description {
                output += "    /// \(description)\n"
            }
            // Use safe name generator for case names
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += "    case \(safeCaseName) = \"\(value.name)\"\n"
        }

        output += "}\n"

        return output
    }
}

package enum GeneratorError: Error, CustomStringConvertible {
    case unsupportedType(String)

    package var description: String {
        switch self {
        case .unsupportedType(let message):
            return "Unsupported type: \(message)"
        }
    }
}
