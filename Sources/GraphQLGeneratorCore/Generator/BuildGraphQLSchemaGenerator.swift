import Foundation
import GraphQL

/// Generates the GraphQL schema builder function
package struct BuildGraphQLSchemaGenerator {
    let nameGenerator: SafeNameGenerator = .idiomatic

    package func generate(schema: GraphQLSchema) throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        /// Build a GraphQL schema with the provided resolvers
        func buildGraphQLSchema<Resolvers: GraphQLGenerated.Resolvers>(
            resolvers: Resolvers.Type,
            decoder: MapDecoder = .init()
        ) throws -> GraphQLSchema {

            let schema = try GraphQL.buildSchema(source: graphQLRawSDL)
        """

        // Ignore any internal types (which have prefix "__")
        let types = schema.typeMap.values.filter {
            !$0.name.hasPrefix("__")
        }

        // Generate type definitions for all object types
        let interfaceTypes = types.compactMap {
            $0 as? GraphQLInterfaceType
        }
        for interfaceType in interfaceTypes {
            output += try"""


            \(generateInterfaceType(for: interfaceType).indent(1))
            """
        }

        // Generate GraphQLObjectType definitions for non-root types
        let objectTypes = types.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip root operation types
            $0.name != schema.queryType?.name &&
                $0.name != schema.mutationType?.name &&
                $0.name != schema.subscriptionType?.name
        }
        for objectType in objectTypes {
            output += try"""


            \(generateObjectType(for: objectType, target: .parent).indent(1))
            """
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += try"""


            \(generateObjectType(for: queryType, target: .query).indent(1))
            """
        }

        // Generate Mutation type if it exists
        if let mutationType = schema.mutationType {
            output += try"""


            \(generateObjectType(for: mutationType, target: .mutation).indent(1))
            """
        }

        // Generate Subscription type if it exists
        if let subscriptionType = schema.subscriptionType {
            output += try"""


            \(generateObjectType(for: subscriptionType, target: .subscription).indent(1))
            """
        }

        output += """


            return schema
        }

        """

        return output
    }

    func generateInterfaceType(for type: GraphQLInterfaceType) throws -> String {
        let typeName = nameGenerator.swiftMemberName(for: type.name)
        let variableName = "\(typeName)Fields"

        var output = """

        let \(typeName) = schema.typeMap["\(type.name)"] as? GraphQLObjectType
        let \(variableName) = try \(typeName)?.fields() ?? [:]
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try """

            \(generateResolverCallback(
                variableName: variableName,
                fieldName: fieldName,
                field: field,
                target: .parent,
                parentType: type
            ))
            """
        }

        output += """

        \(typeName)?.fields = {
            return \(variableName)
        }
        """

        return output
    }

    func generateObjectType(for type: GraphQLObjectType, target: ResolverTarget) throws -> String {
        let typeName = nameGenerator.swiftMemberName(for: type.name)
        let variableName: String
        switch target {
        case .query:
            variableName = "queryFields"
        case .mutation:
            variableName = "mutationFields"
        case .subscription:
            variableName = "subscriptionFields"
        case .parent:
            variableName = "\(typeName)Fields"
        }

        var output = """

        let \(typeName) = schema.typeMap["\(type.name)"] as? GraphQLObjectType
        let \(variableName) = try \(typeName)?.fields() ?? [:]
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try """

            \(generateResolverCallback(
                variableName: variableName,
                fieldName: fieldName,
                field: field,
                target: target,
                parentType: type
            ))
            """
        }

        output += """

        \(typeName)?.fields = {
            return \(variableName)
        }
        """

        return output
    }

    func generateResolverCallback(
        variableName: String,
        fieldName: String,
        field: GraphQLField,
        target: ResolverTarget,
        parentType: GraphQLType
    ) throws -> String {
        var output = ""

        if target == .subscription {
            output += """
            \(variableName)["\(fieldName)"]?.resolve = { source, _, _, _ in
                return source
            }
            \(variableName)["\(fieldName)"]?.subscribe = { source, args, context, info in
            """
        } else {
            output += """
            \(variableName)["\(fieldName)"]?.resolve = { source, args, context, info in
            """
        }

        // Build argument list
        var argsList: [String] = []

        if target == .parent {
            // For nested resolvers, we decode and call the method on the parent instance
            // We use the type Declaration name, since this should always be a non-list, non-nullable instance,
            // and add 'any' because all intermediate types are represented as protocols
            let parentCastType = try swiftTypeDeclaration(for: parentType, includeNamespace: true, nameGenerator: nameGenerator)
            output += """

                let parent = try cast(source, to: (any \(parentCastType)).self)
            """
        }

        // Add field arguments
        for (argName, arg) in field.args {
            let safeArgName = nameGenerator.swiftMemberName(for: argName)
            let swiftType = try swiftTypeReference(for: arg.type, includeNamespace: true, nameGenerator: nameGenerator)
            // Extract value from Map based on type
            var decodeStatement = "try decoder.decode((\(swiftType)).self, from: args[\"\(argName)\"])"
            if !(arg.type is GraphQLNonNull) {
                // If the arg is nullable, we get errors if we try to decode an `undefined` map. This protects against that.
                decodeStatement = "args[\"\(argName)\"] != .undefined ? \(decodeStatement) : nil"
            }
            output += """

                let \(safeArgName) = \(decodeStatement)
            """
            argsList.append("\(safeArgName): \(safeArgName)")
        }

        // Add context
        output += """

            let context = try cast(context, to: GraphQLContext.self)
        """
        argsList.append("context: context")

        // Add resolver info
        argsList.append("info: info")

        // Call the resolver
        let targetName = switch target {
        case .parent: "parent"
        case .query: "Resolvers.Query"
        case .mutation: "Resolvers.Mutation"
        case .subscription: "Resolvers.Subscription"
        }
        let functionName = nameGenerator.swiftMemberName(for: fieldName)
        output += """

            return try await \(targetName).\(functionName)(\(argsList.joined(separator: ", ")))
        }
        """

        return output
    }

    enum ResolverTarget {
        case parent
        case query
        case mutation
        case subscription
    }
}
