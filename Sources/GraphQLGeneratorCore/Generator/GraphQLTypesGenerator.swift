import Foundation
import GraphQL

/// Generates Swift type definitions from GraphQL types
package struct GraphQLTypesGenerator {
    let nameGenerator: SafeNameGenerator = .idiomatic

    package func generate(schema: GraphQLSchema) throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        """

        // Generate Resolvers protocol
        output += """

        enum GraphQLGenerated {
            protocol Resolvers: Sendable {
        """
        if let queryType = schema.queryType {
            try output += """

                    associatedtype Query: \(swiftTypeDeclaration(for: queryType, includeNamespace: true, nameGenerator: nameGenerator))
            """
        }
        if let mutationType = schema.mutationType {
            try output += """

                    associatedtype Mutation: \(swiftTypeDeclaration(for: mutationType, includeNamespace: true, nameGenerator: nameGenerator))
            """
        }
        if let subscriptionType = schema.subscriptionType {
            try output += """

                    associatedtype Subscription: \(swiftTypeDeclaration(for: subscriptionType, includeNamespace: true, nameGenerator: nameGenerator))
            """
        }
        output += """

            }
        """

        // Ignore any internal types (which have prefix "__")
        let types = schema.typeMap.values.filter {
            !$0.name.hasPrefix("__")
        }

        // Generate Enum types
        let enumTypes = types.compactMap {
            $0 as? GraphQLEnumType
        }
        for type in enumTypes {
            output += try"""

            \(generateEnum(for: type).indent(1, includeFirst: true))
            """
        }

        // Generate Input types
        let inputTypes = types.compactMap {
            $0 as? GraphQLInputObjectType
        }
        for type in inputTypes {
            output += try"""

            \(generateInputStruct(for: type).indent(1, includeFirst: true))
            """
        }

        // Generate Union types
        var unionTypeMap = [String: [GraphQLUnionType]]()
        let unionTypes = types.compactMap {
            $0 as? GraphQLUnionType
        }
        for type in unionTypes {
            // Unions are represented by a marker protocol, with associated types conforming

            // Add description if available
            if let description = type.description {
                output += """

                \(description.docComment().indent(1, includeFirst: true))
                """
            }
            let swiftTypeName = try swiftTypeDeclaration(for: type, includeNamespace: false, nameGenerator: nameGenerator)
            output += """

                protocol \(swiftTypeName): Sendable {}
            """

            // Record which types need to be conformed
            for conformingType in try type.types() {
                if unionTypeMap[conformingType.name] != nil {
                    unionTypeMap[conformingType.name]!.append(type)
                } else {
                    unionTypeMap[conformingType.name] = [type]
                }
            }
        }

        // Generate Interface types
        let interfaceTypes = types.compactMap {
            $0 as? GraphQLInterfaceType
        }
        for type in interfaceTypes {
            output += try"""

            \(generateInterfaceProtocol(for: type).indent(1, includeFirst: true))
            """
        }

        // Generate Object types (excluding Query, Mutation, Subscription)
        let objectTypes = types.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip root operation types
            $0.name != schema.queryType?.name &&
                $0.name != schema.mutationType?.name &&
                $0.name != schema.subscriptionType?.name
        }
        for type in objectTypes {
            output += try"""

            \(generateTypeProtocol(for: type, unionTypeMap: unionTypeMap).indent(1, includeFirst: true))
            """
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += try"""

            \(generateRootTypeProtocol(for: queryType).indent(1, includeFirst: true))
            """
        }

        // Generate Mutation type
        if let mutationType = schema.mutationType {
            output += try"""

            \(generateRootTypeProtocol(for: mutationType).indent(1, includeFirst: true))
            """
        }

        // Generate Mutation type
        if let subscriptionType = schema.subscriptionType {
            output += try"""

            \(generateRootTypeProtocol(for: subscriptionType).indent(1, includeFirst: true))
            """
        }
        output += """

        }
        """

        return output
    }

    func generateEnum(for type: GraphQLEnumType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            \(description.docComment())
            """
        }

        let swiftTypeName = try swiftTypeDeclaration(for: type, includeNamespace: false, nameGenerator: nameGenerator)
        output += """

        enum \(swiftTypeName): String, Codable, Sendable {
        """

        // Generate cases
        for value in type.values {
            if let description = value.description {
                output += """

                    \(description.docComment().indent(1, includeFirst: false))
                """
            }
            // Use safe name generator for case names
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += """

                case \(safeCaseName) = "\(value.name)"
            """
        }

        output += """

        }
        """

        return output
    }

    func generateInputStruct(for type: GraphQLInputObjectType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            \(description.docComment())
            """
        }

        let swiftTypeName = try swiftTypeDeclaration(for: type, includeNamespace: false, nameGenerator: nameGenerator)
        output += """

        struct \(swiftTypeName): Codable, Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    \(description.docComment().indent(1, includeFirst: false))
                """
            }

            let returnType = try swiftTypeReference(for: field.type, includeNamespace: false, nameGenerator: nameGenerator)

            output += """

                let \(nameGenerator.swiftMemberName(for: fieldName)): \(returnType)
            """
        }

        // Swift auto-generates memberwise initializers for structs, so we don't need to generate one
        output += """

        }
        """

        return output
    }

    func generateInterfaceProtocol(for type: GraphQLInterfaceType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            \(description.docComment())
            """
        }

        let interfaces = try type.interfaces().map {
            try swiftTypeDeclaration(for: $0, includeNamespace: false, nameGenerator: nameGenerator) + ", "
        }.joined(separator: "")

        let swiftTypeName = try swiftTypeDeclaration(for: type, includeNamespace: false, nameGenerator: nameGenerator)
        output += """

        protocol \(swiftTypeName): \(interfaces)Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    \(description.docComment().indent(1, includeFirst: false))
                """
            }

            let returnType = try swiftTypeReference(for: field.type, includeNamespace: false, nameGenerator: nameGenerator)

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeReference(for: arg.type, includeNamespace: false, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: GraphQLContext")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += """

                func \(nameGenerator.swiftMemberName(for: fieldName))(\(paramString)) async throws -> \(returnType)

            """
        }

        output += """

        }
        """

        return output
    }

    func generateTypeProtocol(for type: GraphQLObjectType, unionTypeMap: [String: [GraphQLUnionType]]) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            \(description.docComment())
            """
        }

        let unions = try unionTypeMap[type.name]?.map {
            try swiftTypeDeclaration(for: $0, includeNamespace: false, nameGenerator: nameGenerator) + ", "
        }.joined(separator: "") ?? ""

        let interfaces = try type.interfaces().map {
            try swiftTypeDeclaration(for: $0, includeNamespace: false, nameGenerator: nameGenerator) + ", "
        }.joined(separator: "")

        let swiftTypeName = try swiftTypeDeclaration(for: type, includeNamespace: false, nameGenerator: nameGenerator)
        output += """

        protocol \(swiftTypeName): \(unions)\(interfaces)Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    \(description.docComment().indent(1, includeFirst: false))
                """
            }

            let returnType = try swiftTypeReference(for: field.type, includeNamespace: false, nameGenerator: nameGenerator)

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeReference(for: arg.type, includeNamespace: false, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: GraphQLContext")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += """

                func \(nameGenerator.swiftMemberName(for: fieldName))(\(paramString)) async throws -> \(returnType)

            """
        }

        output += """

        }
        """

        return output
    }

    /// Root types are the same as normal types, except that their functions are static and they cannot
    /// inherit from interfaces or unions
    func generateRootTypeProtocol(for type: GraphQLObjectType) throws -> String {
        var output = ""

        // Add description if available
        if let description = type.description {
            output += """

            \(description.docComment())
            """
        }

        let swiftTypeName = try swiftTypeDeclaration(for: type, includeNamespace: false, nameGenerator: nameGenerator)
        output += """

        protocol \(swiftTypeName): Sendable {
        """

        // Generate properties
        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += """

                    \(description.docComment().indent(1, includeFirst: false))
                """
            }

            var returnType = try swiftTypeReference(for: field.type, includeNamespace: false, nameGenerator: nameGenerator)
            if type.name == "Subscription" {
                returnType = "AnyAsyncSequence<\(returnType)>"
            }

            var params: [String] = []

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeReference(for: arg.type, includeNamespace: false, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: GraphQLContext")

            // Add resolve info parameter
            params.append("info: GraphQLResolveInfo")

            let paramString = params.joined(separator: ", ")

            output += """

                static func \(nameGenerator.swiftMemberName(for: fieldName))(\(paramString)) async throws -> \(returnType)

            """
        }

        output += """

        }
        """

        return output
    }
}

package enum GeneratorError: Error, CustomStringConvertible {
    case unsupportedType(String)

    package var description: String {
        switch self {
        case let .unsupportedType(message):
            return "Unsupported type: \(message)"
        }
    }
}
