import Foundation
import GraphQL

/// Generates the GraphQL schema builder function
package struct SchemaGenerator {
    let schema: GraphQLSchema
    let nameGenerator: SafeNameGenerator = .idiomatic

    package init(schema: GraphQLSchema) {
        self.schema = schema
    }

    package func generate() throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        /// Build a GraphQL schema with the provided resolvers
        public func buildGraphQLSchema(resolvers: GraphQLResolvers) throws -> GraphQLSchema {

        """

        let typeMap = schema.typeMap

        // TODO: Scalars

        // Generate enum type definitions
        let enumTypes = typeMap.values.compactMap { $0 as? GraphQLEnumType }
        for enumType in enumTypes {
            // Skip GraphQL internal enums
            if enumType.name.hasPrefix("__") {
                continue
            }

            output += try generateEnumTypeDefinition(for: enumType).indent(1)
            output += "\n"
        }

        // Generate type definitions for all object types
        let interfaceTypes = typeMap.values.compactMap {
            $0 as? GraphQLInterfaceType
        }.filter {
            // Skip introspection types and root operation types
            !$0.name.hasPrefix("__")
        }

        for interfaceType in interfaceTypes {
            output += try generateInterfaceTypeDefinition(for: interfaceType, resolvers: "resolvers").indent(1)
            output += "\n"
        }

        // TODO: Input Objects

        // Generate type definitions for all object types
        let objectTypes = typeMap.values.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip introspection types and root operation types
            !$0.name.hasPrefix("__") &&
            $0.name != "Query" &&
            $0.name != "Mutation" &&
            $0.name != "Subscription"
        }

        // Generate GraphQLObjectType definitions for non-root types
        for objectType in objectTypes {
            output += try generateObjectTypeDefinition(for: objectType, resolvers: "resolvers").indent(1)
            output += "\n"
        }

        // Generate GraphQLObjectType field definitions for non-root types
        for interfaceType in interfaceTypes {
            output += try generateInterfaceTypeFieldDefinition(for: interfaceType, resolvers: "resolvers").indent(1)
            output += "\n"
        }
        for objectType in objectTypes {
            output += try generateObjectTypeFieldDefinition(for: objectType, resolvers: "resolvers").indent(1)
            output += "\n"
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += try generateQueryTypeDefinition(for: queryType, resolvers: "resolvers").indent(1)
            output += "\n"
        }

        // Generate Mutation type if it exists
        if let mutationType = schema.mutationType {
            output += try generateMutationTypeDefinition(for: mutationType, resolvers: "resolvers").indent(1)
            output += "\n"
        }

        // TODO: Subscription

        // Build and return the schema
        output += """
            return try GraphQLSchema(
                query: queryType
        """

        if schema.mutationType != nil {
            output += """
            ,
                    mutation: mutationType
            """
        }

        output += """

            )
        }

        """

        return output
    }

    private func generateEnumTypeDefinition(for type: GraphQLEnumType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Type"

        var output = """

        let \(varName) = try GraphQLEnumType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            values: [
        """

        for value in type.values {
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += """

                    "\(value.name)": GraphQLEnumValue(
            """

            if let description = value.description {
                output += """

                            value: \(safeCaseName),
                            description:  \"\"\"
                            \(description.indent(3, includeFirst: false))
                            \"\"\",
                """
            } else {
                output += """

                            value: .string("\(value.name)")
                """
            }

            output += """

                    ),
            """
        }

        output += """

            ]
        )
        """

        return output
    }

    private func generateInterfaceTypeDefinition(for type: GraphQLInterfaceType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Interface"

        var output = """
        let \(varName) = try GraphQLInterfaceType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Delay field & interface generation to support recursive type systems

        output += """

        )
        """

        return output
    }

    private func generateInterfaceTypeFieldDefinition(for type: GraphQLInterfaceType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Interface"

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            // For non-root types, only generate resolver callbacks for fields that return object types
            let needsResolver = isObjectType(field.type)

            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: type.name,
                resolvers: resolvers,
                isRootType: false,
                needsResolver: needsResolver
            ).indent(2)
        }

        output += """

            ]
        }
        """

        return output
    }


    private func generateObjectTypeDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Type"

        var output = """
        let \(varName) = try GraphQLObjectType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Delay field generation to support recursive type systems

        output += """

        )
        """

        return output
    }

    private func generateObjectTypeFieldDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Type"

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            // For non-root types, only generate resolver callbacks for fields that return object types
            let needsResolver = isObjectType(field.type)

            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: type.name,
                resolvers: resolvers,
                isRootType: false,
                needsResolver: needsResolver
            ).indent(2)
        }

        output += """

            ]
        }
        """

        return output
    }

    private func generateQueryTypeDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        var output = """

        let queryType = try GraphQLObjectType(
            name: "Query",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            fields: [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: "Query",
                resolvers: resolvers,
                isRootType: true
            ).indent(2)
        }

        output += """

            ]
        )
        """

        return output
    }

    private func generateMutationTypeDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        var output = """

        let mutationType = try GraphQLObjectType(
            name: "Mutation",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            fields: [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: "Mutation",
                resolvers: resolvers,
                isRootType: true
            ).indent(2)
        }

        output += """

            ]
        )
        """

        return output
    }

    private func generateFieldDefinition(
        fieldName: String,
        field: GraphQLField,
        parentTypeName: String,
        resolvers: String,
        isRootType: Bool,
        needsResolver: Bool = true
    ) throws -> String {
        var output = """

        "\(fieldName)": GraphQLField(
            type: \(try graphQLTypeReference(for: field.type)),
        """

        if let description = field.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Add arguments if any
        if !field.args.isEmpty {
            output += """

                args: [
            """

            for (argName, arg) in field.args {
                output += """

                        "\(argName)": GraphQLArgument(
                            type: \(try graphQLTypeReference(for: arg.type))
                """

                if let description = arg.description {
                    output += """
                    ,
                            description: \"\"\"
                            \(description)
                            \"\"\"
                    """
                }

                output += """

                        ),
                """
            }

            output += """

                ],
            """
        }

        // Generate resolver function only if needed
        if needsResolver {
            output += try generateResolverCallback(
                fieldName: fieldName,
                field: field,
                parentTypeName: parentTypeName,
                resolvers: resolvers,
                isRootType: isRootType
            ).indent(1)
        }

        output += """

        ),
        """

        return output
    }

    private func generateResolverCallback(
        fieldName: String,
        field: GraphQLField,
        parentTypeName: String,
        resolvers: String,
        isRootType: Bool
    ) throws -> String {
        let safeFieldName = nameGenerator.swiftMemberName(for: fieldName)

        var output = """

        resolve: { source, args, context, info in
        """

        // Build argument list
        var argsList: [String] = []

        if !isRootType {
            // For nested resolvers, first argument is the parent object
            let safeParentTypeName = nameGenerator.swiftTypeName(for: parentTypeName)
            output += """

                guard let parent = source as? \(safeParentTypeName) else {
                    throw GraphQLError(
                        message: "Expected source type \(safeParentTypeName) but got \\(type(of: source))"
                    )
                }
            """
            argsList.append("parent: parent")
        }

        // Add field arguments
        for (argName, arg) in field.args {
            let safeArgName = nameGenerator.swiftMemberName(for: argName)
            let swiftType = try swiftTypeName(for: arg.type, nameGenerator: nameGenerator)
            // Extract value from Map based on type
            output += """

                let \(safeArgName) = try MapDecoder().decode(\(swiftType).self, from: args["\(argName)"])
            """
            argsList.append("\(safeArgName): \(safeArgName)")
        }

        // Add context
        output += """

            guard let context = context as? ResolverContext else {
                throw GraphQLError(
                        message: "Expected context type ResolverContext but got \\(type(of: context))"
                )
            }
        """
        argsList.append("context: context")

        // Add resolver info
        argsList.append("info: info")

        // Call the resolver
        let resolverMethodName: String
        if isRootType {
            resolverMethodName = safeFieldName
        } else {
            let parentName = nameGenerator.swiftMemberName(for: parentTypeName)
            let fieldNameCapitalized = safeFieldName.prefix(1).uppercased() + safeFieldName.dropFirst()
            resolverMethodName = "\(parentName)\(fieldNameCapitalized)"
        }

        output += """

            return try await \(resolvers).\(resolverMethodName)(\(argsList.joined(separator: ", ")))
        }
        """

        return output
    }

    /// Generate GraphQL type reference string (e.g., "GraphQLString", "GraphQLNonNull(GraphQLString)")
    private func graphQLTypeReference(for type: GraphQLType) throws -> String {
        if let nonNull = type as? GraphQLNonNull {
            return "GraphQLNonNull(\(try graphQLTypeReference(for: nonNull.ofType)))"
        }

        if let list = type as? GraphQLList {
            return "GraphQLList(\(try graphQLTypeReference(for: list.ofType)))"
        }

        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name

            // Map to built-in GraphQL types
            switch typeName {
            case "ID": return "GraphQLID"
            case "String": return "GraphQLString"
            case "Int": return "GraphQLInt"
            case "Float": return "GraphQLFloat"
            case "Boolean": return "GraphQLBoolean"
            default:
                // Reference to a custom type variable
                let varName = nameGenerator.swiftMemberName(for: typeName) + "Type"
                return varName
            }
        }

        throw GeneratorError.unsupportedType("Unknown type: \(type)")
    }

    /// Generate code to convert a Map value to a Swift type
    private func mapConversionCode(for type: GraphQLType, valueName: String, swiftType: String) throws -> String {
        // For non-null types, unwrap and convert
        if let nonNull = type as? GraphQLNonNull {
            let innerCode = try mapConversionCode(for: nonNull.ofType, valueName: valueName, swiftType: String(swiftType.dropLast()))
            return innerCode
        }

        // For list types, map over the array
        if let list = type as? GraphQLList {
            return "try \(valueName).arrayValue?.map { try \(try swiftTypeName(for: list.ofType, nameGenerator: nameGenerator))($0) }"
        }

        // For named types, convert based on scalar type
        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name

            switch typeName {
            case "ID", "String":
                return "\(valueName).string!"
            case "Int":
                return "\(valueName).int!"
            case "Float":
                return "\(valueName).double!"
            case "Boolean":
                return "\(valueName).bool!"
            default:
                // For custom types (enums, etc.), try to decode
                return "try \(swiftType)(\(valueName))"
            }
        }

        throw GeneratorError.unsupportedType("Unknown type: \(type)")
    }

    /// Check if a GraphQL type is a composite object type (not a scalar, enum, etc.)
    private func isObjectType(_ type: GraphQLType) -> Bool {
        // Unwrap NonNull and List
        if let nonNull = type as? GraphQLNonNull {
            return isObjectType(nonNull.ofType)
        }
        if let list = type as? GraphQLList {
            return isObjectType(list.ofType)
        }

        // Check if it's a named object type (not a scalar or enum)
        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name
            // Built-in scalars are not object types
            if ["ID", "String", "Int", "Float", "Boolean"].contains(typeName) {
                return false
            }
            // Check if it's a composite type (not an enum or scalar)
            return namedType is GraphQLCompositeType
        }

        return false
    }
}
