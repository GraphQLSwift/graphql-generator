import Foundation
import GraphQL

/// Generates the GraphQL schema builder function
package struct SchemaGenerator {
    let nameGenerator: SafeNameGenerator = .idiomatic

    package func generate(schema: GraphQLSchema) throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        /// Build a GraphQL schema with the provided resolvers
        public func buildGraphQLSchema<Resolvers: ResolversProtocol>(resolvers: Resolvers.Type) throws -> GraphQLSchema {
        """

        // Ignore any internal types (which have prefix "__")
        let types = schema.typeMap.values.filter {
            !$0.name.hasPrefix("__")
        }

        // Generate scalar type definitions
        let scalarTypes = types.compactMap {
            $0 as? GraphQLScalarType
        }.filter {
            // Exclude the standard scalars
            !["Int", "Float", "String", "Boolean", "ID"].contains($0.name)
        }
        for scalarType in scalarTypes {
            output += """

            \(try generateScalarTypeDefinition(for: scalarType).indent(1))
            """
        }

        // Generate enum type definitions
        let enumTypes = types.compactMap { $0 as? GraphQLEnumType }
        for enumType in enumTypes {
            output += """

            \(try generateEnumTypeDefinition(for: enumType).indent(1))
            """
        }

        // Generate type definitions for all object types
        let interfaceTypes = types.compactMap {
            $0 as? GraphQLInterfaceType
        }
        for interfaceType in interfaceTypes {
            output += """

            \(try generateInterfaceTypeDefinition(for: interfaceType, resolvers: "resolvers").indent(1))
            """
        }

        // Generate type definitions for all input object types
        let inputTypes = types.compactMap {
            $0 as? GraphQLInputObjectType
        }
        for inputType in inputTypes {
            output += """

            \(try generateInputTypeDefinition(for: inputType).indent(1))
            """
        }

        // Generate type definitions for all object types

        // Generate GraphQLObjectType definitions for non-root types
        let objectTypes = types.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip root operation types
            $0.name != "Query" &&
            $0.name != "Mutation" &&
            $0.name != "Subscription"
        }
        for objectType in objectTypes {
            output += """

            \(try generateObjectTypeDefinition(for: objectType).indent(1))
            """
        }
        // Generate type definitions for all union object types
        let unionTypes = types.compactMap {
            $0 as? GraphQLUnionType
        }
        for unionType in unionTypes {
            output += """

            \(try generateUnionTypeDefinition(for: unionType).indent(1))
            """
        }

        // Generate field and interface definitions for non-root types
        for inputType in inputTypes {
            output += """

            \(try generateInputTypeFieldDefinition(for: inputType).indent(1))
            """
        }
        for interfaceType in interfaceTypes {
            output += """

            \(try generateInterfaceTypeFieldDefinition(for: interfaceType).indent(1))
            """
        }
        for objectType in objectTypes {
            output += """

            \(try generateObjectTypeFieldDefinition(for: objectType, resolvers: "parent").indent(1))
            """
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += """

            \(try generateQueryTypeDefinition(for: queryType).indent(1))
            """
        }

        // Generate Mutation type if it exists
        if let mutationType = schema.mutationType {
            output += """

            \(try generateMutationTypeDefinition(for: mutationType).indent(1))
            """
        }

        // TODO: Subscription

        // Build and return the schema
        output += """

            return try GraphQLSchema(
                query: query
        """

        if schema.mutationType != nil {
            output += """
            ,
                    mutation: mutation
            """
        }

        output += """

            )
        }

        """

        return output
    }

    private func generateScalarTypeDefinition(for type: GraphQLScalarType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        // We expect the user to define a type of the same name that conforms to provided "Scalar" protocol
        return """

        let \(varName) = try GraphQLScalarType(
            name: "\(type.name)",
            serialize: { any in
                try \(type.name).serialize(any: any)
            },
            parseValue: { map in
                try \(type.name).parseValue(map: map)
            },
            parseLiteral: { value in
                try \(type.name).parseLiteral(value: value)
            }
        )
        """
    }

    private func generateEnumTypeDefinition(for type: GraphQLEnumType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """

        let \(varName) = try GraphQLEnumType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            values: [
        """

        for value in type.values {
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += """

                    "\(value.name)": GraphQLEnumValue(
            """

            if let description = value.description {
                output += """

                            value: \(safeCaseName),
                            description:  \"\"\"
                            \(description.indent(3, includeFirst: false))
                            \"\"\",
                """
            } else {
                output += """

                            value: .string("\(value.name)")
                """
            }

            output += """

                    ),
            """
        }

        output += """

            ]
        )
        """

        return output
    }

    private func generateInputTypeDefinition(for type: GraphQLInputObjectType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLInputObjectType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Delay field generation to support recursive type systems
        output += """

        )
        """

        return output
    }

    private func generateInputTypeFieldDefinition(for type: GraphQLInputObjectType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += """

                    "\(fieldName)": InputObjectField(
                        type: \(try graphQLTypeReference(for: field.type)),
            """

            // TODO: Default value support

            if let description = field.description {
                output += """

                            description: \"\"\"
                            \(description)
                            \"\"\",
                """
            }
            if let deprecationReason = field.deprecationReason {
                output += """

                            deprecationReason: \"\"\"
                            \(deprecationReason)
                            \"\"\"
                """
            }

            output += """

                    )
            """
        }

        output += """

            ]
        }
        """

        return output
    }

    private func generateInterfaceTypeDefinition(for type: GraphQLInterfaceType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLInterfaceType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Delay field & interface generation to support recursive type systems

        output += """

        )
        """

        return output
    }

    private func generateInterfaceTypeFieldDefinition(for type: GraphQLInterfaceType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {

            output += """

            \(try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: .parent,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        }
        """

        let interfaces = try type.interfaces()
        if !interfaces.isEmpty {
            output += """

            \(varName).interfaces = {
                [
            """

            // Generate fields
            for interface in interfaces {
                output += """

                        \(nameGenerator.swiftMemberName(for: interface.name))
                """
            }

            output += """

                ]
            }
            """
        }

        return output
    }

    private func generateObjectTypeDefinition(for type: GraphQLObjectType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLObjectType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Delay field generation to support recursive type systems
        output += """

        )
        """

        return output
    }

    private func generateObjectTypeFieldDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += """

            \(try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: .parent,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        }
        """

        let interfaces = try type.interfaces()
        if !interfaces.isEmpty {
            output += """

            \(varName).interfaces = {
                [
            """

            // Generate fields
            for interface in interfaces {
                output += """

                        \(nameGenerator.swiftMemberName(for: interface.name))
                """
            }

            output += """

                ]
            }
            """
        }

        return output
    }

    private func generateUnionTypeDefinition(for type: GraphQLUnionType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLUnionType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        output += """

            types: [
        """
        for type in try type.types() {
            output += """

                    \(try graphQLTypeReference(for: type)),
            """
        }

        // Delay type generation to support recursive type systems
        output += """

            ]
        )
        """

        return output
    }

    private func generateQueryTypeDefinition(for type: GraphQLObjectType) throws -> String {
        var output = """

        let query = try GraphQLObjectType(
            name: "Query",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            fields: [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += """

            \(try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: .query,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        )
        """

        return output
    }

    private func generateMutationTypeDefinition(for type: GraphQLObjectType) throws -> String {
        var output = """

        let mutation = try GraphQLObjectType(
            name: "Mutation",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            fields: [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += """

            \(try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: .mutation,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        )
        """

        return output
    }

    private func generateFieldDefinition(
        fieldName: String,
        field: GraphQLField,
        target: ResolverTarget,
        parentType: GraphQLType
    ) throws -> String {
        var output = """

        "\(fieldName)": GraphQLField(
            type: \(try graphQLTypeReference(for: field.type)),
        """

        if let description = field.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        if let deprecationReason = field.deprecationReason {
            output += """

                deprecationReason: \"\"\"
                \(deprecationReason)
                \"\"\",
            """
        }

        // Add arguments if any
        if !field.args.isEmpty {
            output += """

                args: [
            """

            for (argName, arg) in field.args {
                output += """

                        "\(argName)": GraphQLArgument(
                            type: \(try graphQLTypeReference(for: arg.type))
                """

                if let description = arg.description {
                    output += """
                    ,
                            description: \"\"\"
                            \(description)
                            \"\"\"
                    """
                }

                output += """

                        ),
                """
            }

            output += """

                ],
            """
        }

        output += """

        \(try generateResolverCallback(
            fieldName: fieldName,
            field: field,
            target: target,
            parentType: parentType
        ).indent(1))
        ),
        """

        return output
    }

    private func generateResolverCallback(
        fieldName: String,
        field: GraphQLField,
        target: ResolverTarget,
        parentType: GraphQLType
    ) throws -> String {
        let safeFieldName = nameGenerator.swiftMemberName(for: fieldName)

        var output = """

        resolve: { source, args, context, info in
        """

        // Build argument list
        var argsList: [String] = []

        if target == .parent {
            // For nested resolvers, we decode and call the method on the parent instance
            let parentCastType = try swiftTypeReference(for: parentType, nameGenerator: nameGenerator)
            output += """

                let parent = try cast(source, to: (\(parentCastType)).self)
            """
        }

        // Add field arguments
        for (argName, arg) in field.args {
            let safeArgName = nameGenerator.swiftMemberName(for: argName)
            let swiftType = try swiftTypeReference(for: arg.type, nameGenerator: nameGenerator)
            // Extract value from Map based on type
            output += """

                let \(safeArgName) = try MapDecoder().decode((\(swiftType)).self, from: args["\(argName)"])
            """
            argsList.append("\(safeArgName): \(safeArgName)")
        }

        // Add context
        output += """

            let context = try cast(context, to: Context.self)
        """
        argsList.append("context: context")

        // Add resolver info
        argsList.append("info: info")

        // Call the resolver
        let targetName = switch target {
            case .parent: "parent"
            case .query: "Resolvers.Query"
            case .mutation:  "Resolvers.Mutation"
        }
        output += """

            return try await \(targetName).\(safeFieldName)(\(argsList.joined(separator: ", ")))
        }
        """

        return output
    }

    /// Generate GraphQL type reference string (e.g., "GraphQLString", "GraphQLNonNull(GraphQLString)")
    private func graphQLTypeReference(for type: GraphQLType) throws -> String {
        if let nonNull = type as? GraphQLNonNull {
            return "GraphQLNonNull(\(try graphQLTypeReference(for: nonNull.ofType)))"
        }

        if let list = type as? GraphQLList {
            return "GraphQLList(\(try graphQLTypeReference(for: list.ofType)))"
        }

        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name

            // Map to built-in GraphQL types
            switch typeName {
            case "ID": return "GraphQLID"
            case "String": return "GraphQLString"
            case "Int": return "GraphQLInt"
            case "Float": return "GraphQLFloat"
            case "Boolean": return "GraphQLBoolean"
            default:
                // Reference to a custom type variable
                let varName = nameGenerator.swiftMemberName(for: typeName)
                return varName
            }
        }

        throw GeneratorError.unsupportedType("Unknown type: \(type)")
    }

    private enum ResolverTarget {
        case parent
        case query
        case mutation
    }
}
