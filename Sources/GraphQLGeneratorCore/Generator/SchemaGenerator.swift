import Foundation
import GraphQL

/// Generates the GraphQL schema builder function
package struct SchemaGenerator {
    let nameGenerator: SafeNameGenerator = .idiomatic

    package func generate(schema: GraphQLSchema) throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        /// Build a GraphQL schema with the provided resolvers
        public func buildGraphQLSchema<Resolvers: ResolversProtocol>(
            resolvers: Resolvers.Type,
            decoder: MapDecoder = .init()
        ) throws -> GraphQLSchema {
        """

        // Ignore any internal types (which have prefix "__")
        let types = schema.typeMap.values.filter {
            !$0.name.hasPrefix("__")
        }

        // Generate scalar type definitions
        let scalarTypes = types.compactMap {
            $0 as? GraphQLScalarType
        }.filter {
            // Exclude the standard scalars
            !["Int", "Float", "String", "Boolean", "ID"].contains($0.name)
        }
        for scalarType in scalarTypes {
            output += try"""

            \(generateScalarTypeDefinition(for: scalarType).indent(1))
            """
        }

        // Generate enum type definitions
        let enumTypes = types.compactMap { $0 as? GraphQLEnumType }
        for enumType in enumTypes {
            output += try"""

            \(generateEnumTypeDefinition(for: enumType).indent(1))
            """
        }

        // Generate type definitions for all object types
        let interfaceTypes = types.compactMap {
            $0 as? GraphQLInterfaceType
        }
        for interfaceType in interfaceTypes {
            output += try"""

            \(generateInterfaceTypeDefinition(for: interfaceType, resolvers: "resolvers").indent(1))
            """
        }

        // Generate type definitions for all input object types
        let inputTypes = types.compactMap {
            $0 as? GraphQLInputObjectType
        }
        for inputType in inputTypes {
            output += try"""

            \(generateInputTypeDefinition(for: inputType).indent(1))
            """
        }

        // Generate type definitions for all object types

        // Generate GraphQLObjectType definitions for non-root types
        let objectTypes = types.compactMap {
            $0 as? GraphQLObjectType
        }.filter {
            // Skip root operation types
            $0.name != "Query" &&
                $0.name != "Mutation" &&
                $0.name != "Subscription"
        }
        for objectType in objectTypes {
            output += try"""

            \(generateObjectTypeDefinition(for: objectType).indent(1))
            """
        }
        // Generate type definitions for all union object types
        let unionTypes = types.compactMap {
            $0 as? GraphQLUnionType
        }
        for unionType in unionTypes {
            output += try"""

            \(generateUnionTypeDefinition(for: unionType).indent(1))
            """
        }

        // Generate field and interface definitions for non-root types
        for inputType in inputTypes {
            output += try"""

            \(generateInputTypeFieldDefinition(for: inputType).indent(1))
            """
        }
        for interfaceType in interfaceTypes {
            output += try"""

            \(generateInterfaceTypeFieldDefinition(for: interfaceType).indent(1))
            """
        }
        for objectType in objectTypes {
            output += try"""

            \(generateObjectTypeFieldDefinition(for: objectType, resolvers: "parent").indent(1))
            """
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += try"""

            \(generateRootTypeDefinition(for: queryType, rootType: .query).indent(1))
            """
        }

        // Generate Mutation type if it exists
        if let mutationType = schema.mutationType {
            output += try"""

            \(generateRootTypeDefinition(for: mutationType, rootType: .mutation).indent(1))
            """
        }

        // Generate Subscription type if it exists
        if let subscriptionType = schema.subscriptionType {
            output += try"""

            \(generateRootTypeDefinition(for: subscriptionType, rootType: .subscription).indent(1))
            """
        }

        // TODO: Subscription

        // Build and return the schema
        output += """

            return try GraphQLSchema(
                query: query
        """

        if schema.mutationType != nil {
            output += """
            ,
                    mutation: mutation
            """
        }

        if schema.subscriptionType != nil {
            output += """
            ,
                    subscription: subscription
            """
        }

        output += """

            )
        }

        """

        return output
    }

    func generateScalarTypeDefinition(for type: GraphQLScalarType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        // We expect the user to define a type of the same name that conforms to provided "Scalar" protocol
        return """

        let \(varName) = try GraphQLScalarType(
            name: "\(type.name)",
            serialize: { any in
                try \(type.name).serialize(any: any)
            },
            parseValue: { map in
                try \(type.name).parseValue(map: map)
            },
            parseLiteral: { value in
                try \(type.name).parseLiteral(value: value)
            }
        )
        """
    }

    func generateEnumTypeDefinition(for type: GraphQLEnumType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """

        let \(varName) = try GraphQLEnumType(
            name: "\(type.name)"
        """

        if let description = type.description {
            output += """
            ,
                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\"
            """
        }

        output += """
        ,
            values: [
        """

        for value in type.values {
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += """

                    "\(value.name)": GraphQLEnumValue(
            """

            if let description = value.description {
                output += """

                            value: \(safeCaseName),
                            description:  \"\"\"
                            \(description.indent(3, includeFirst: false))
                            \"\"\",
                """
            } else {
                output += """

                            value: .string("\(value.name)")
                """
            }

            output += """

                    ),
            """
        }

        output += """

            ]
        )
        """

        return output
    }

    func generateInputTypeDefinition(for type: GraphQLInputObjectType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLInputObjectType(
            name: "\(type.name)"
        """

        if let description = type.description {
            output += """
            ,
                description: \"\"\"
                \(description)
                \"\"\"
            """
        }

        // Delay field generation to support recursive type systems
        output += """

        )
        """

        return output
    }

    func generateInputTypeFieldDefinition(for type: GraphQLInputObjectType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try """

                    "\(fieldName)": InputObjectField(
                        type: \(graphQLTypeReference(for: field.type))
            """

            if let defaultValue = field.defaultValue {
                output += """
                ,
                            defaultValue: \(mapToSwiftCode(defaultValue))
                """
            }

            if let description = field.description {
                output += """
                ,
                            description: \"\"\"
                            \(description)
                            \"\"\"
                """
            }
            if let deprecationReason = field.deprecationReason {
                output += """
                ,
                            deprecationReason: \"\"\"
                            \(deprecationReason)
                            \"\"\"
                """
            }

            output += """

                    ),
            """
        }

        output += """

            ]
        }
        """

        return output
    }

    func generateInterfaceTypeDefinition(for type: GraphQLInterfaceType, resolvers _: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLInterfaceType(
            name: "\(type.name)"
        """

        if let description = type.description {
            output += """
            ,
                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        // Delay field & interface generation to support recursive type systems

        output += """

        )
        """

        return output
    }

    func generateInterfaceTypeFieldDefinition(for type: GraphQLInterfaceType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try"""

            \(generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: .parent,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        }
        """

        let interfaces = try type.interfaces()
        if !interfaces.isEmpty {
            output += """

            \(varName).interfaces = {
                [
            """

            // Generate fields
            for interface in interfaces {
                output += """

                        \(nameGenerator.swiftMemberName(for: interface.name)),
                """
            }

            output += """

                ]
            }
            """
        }

        return output
    }

    func generateObjectTypeDefinition(for type: GraphQLObjectType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLObjectType(
            name: "\(type.name)"
        """

        if let description = type.description {
            output += """
            ,
                description: \"\"\"
                \(description)
                \"\"\"
            """
        }

        // Delay field generation to support recursive type systems
        output += """

        )
        """

        return output
    }

    func generateObjectTypeFieldDefinition(for type: GraphQLObjectType, resolvers _: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        \(varName).fields = {
            [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try"""

            \(generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: .parent,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        }
        """

        let interfaces = try type.interfaces()
        if !interfaces.isEmpty {
            output += """

            \(varName).interfaces = {
                [
            """

            // Generate fields
            for interface in interfaces {
                output += """

                        \(nameGenerator.swiftMemberName(for: interface.name)),
                """
            }

            output += """

                ]
            }
            """
        }

        return output
    }

    func generateUnionTypeDefinition(for type: GraphQLUnionType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name)

        var output = """
        let \(varName) = try GraphQLUnionType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description)
                \"\"\",
            """
        }

        output += """

            types: [
        """
        for type in try type.types() {
            output += try"""

                    \(graphQLTypeReference(for: type)),
            """
        }

        // Delay type generation to support recursive type systems
        output += """

            ]
        )
        """

        return output
    }

    func generateRootTypeDefinition(for type: GraphQLObjectType, rootType: RootType) throws -> String {
        let variableName: String
        let target: ResolverTarget
        switch rootType {
        case .query:
            variableName = "query"
            target = .query
        case .mutation:
            variableName = "mutation"
            target = .mutation
        case .subscription:
            variableName = "subscription"
            target = .subscription
        }

        var output = """

        let \(variableName) = try GraphQLObjectType(
            name: "\(type.name)",
        """

        if let description = type.description {
            output += """

                description: \"\"\"
                \(description.indent(1, includeFirst: false))
                \"\"\",
            """
        }

        output += """

            fields: [
        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try"""

            \(generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                target: target,
                parentType: type
            ).indent(2))
            """
        }

        output += """

            ]
        )
        """

        return output
    }

    func generateFieldDefinition(
        fieldName: String,
        field: GraphQLField,
        target: ResolverTarget,
        parentType: GraphQLNamedType
    ) throws -> String {
        var output = try """

        "\(fieldName)": GraphQLField(
            type: \(graphQLTypeReference(for: field.type))
        """

        if let description = field.description {
            output += """
            ,
                description: \"\"\"
                \(description)
                \"\"\"
            """
        }

        if let deprecationReason = field.deprecationReason {
            output += """
            ,
                deprecationReason: \"\"\"
                \(deprecationReason)
                \"\"\"
            """
        }

        // Add arguments if any
        if !field.args.isEmpty {
            output += """
            ,
                args: [
            """

            for (argName, arg) in field.args {
                output += try """

                        "\(argName)": GraphQLArgument(
                            type: \(graphQLTypeReference(for: arg.type))
                """

                if let description = arg.description {
                    output += """
                    ,
                                description: \"\"\"
                                \(description)
                                \"\"\"
                    """
                }

                if let defaultValue = arg.defaultValue {
                    output += """
                    ,
                                defaultValue: \(mapToSwiftCode(defaultValue))
                    """
                }

                output += """

                        ),
                """
            }

            output += """

                ]
            """
        }

        output += try"""
        ,
        \(generateResolverCallback(
            fieldName: fieldName,
            field: field,
            target: target,
            parentType: parentType
        ).indent(1))
        ),
        """

        return output
    }

    func generateResolverCallback(
        fieldName: String,
        field: GraphQLField,
        target: ResolverTarget,
        parentType: GraphQLType
    ) throws -> String {
        var output = ""

        if target == .subscription {
            output += """

            resolve: { source, _, _, _ in
                return source
            },
            subscribe: { source, args, context, info in
            """
        } else {
            output += """

            resolve: { source, args, context, info in
            """
        }

        // Build argument list
        var argsList: [String] = []

        if target == .parent {
            // For nested resolvers, we decode and call the method on the parent instance
            // We use the type Declaration name, since this should always be a non-list, non-nullable instance,
            // and add 'any' because all intermediate types are represented as protocols
            let parentCastType = try swiftTypeDeclaration(for: parentType, nameGenerator: nameGenerator)
            output += """

                let parent = try cast(source, to: (any \(parentCastType)).self)
            """
        }

        // Add field arguments
        for (argName, arg) in field.args {
            let safeArgName = nameGenerator.swiftMemberName(for: argName)
            let swiftType = try swiftTypeReference(for: arg.type, nameGenerator: nameGenerator)
            // Extract value from Map based on type
            var decodeStatement = "try decoder.decode((\(swiftType)).self, from: args[\"\(argName)\"])"
            if !(arg.type is GraphQLNonNull) {
                // If the arg is nullable, we get errors if we try to decode an `undefined` map. This protects against that.
                decodeStatement = "args[\"\(argName)\"] != .undefined ? \(decodeStatement) : nil"
            }
            output += """

                let \(safeArgName) = \(decodeStatement)
            """
            argsList.append("\(safeArgName): \(safeArgName)")
        }

        // Add context
        output += """

            let context = try cast(context, to: Context.self)
        """
        argsList.append("context: context")

        // Add resolver info
        argsList.append("info: info")

        // Call the resolver
        let targetName = switch target {
        case .parent: "parent"
        case .query: "Resolvers.Query"
        case .mutation: "Resolvers.Mutation"
        case .subscription: "Resolvers.Subscription"
        }
        let functionName = nameGenerator.swiftMemberName(for: fieldName)
        output += """

            return try await \(targetName).\(functionName)(\(argsList.joined(separator: ", ")))
        }
        """

        return output
    }

    /// Generate GraphQL type reference string (e.g., "GraphQLString", "GraphQLNonNull(GraphQLString)")
    func graphQLTypeReference(for type: GraphQLType) throws -> String {
        if let nonNull = type as? GraphQLNonNull {
            return try "GraphQLNonNull(\(graphQLTypeReference(for: nonNull.ofType)))"
        }

        if let list = type as? GraphQLList {
            return try "GraphQLList(\(graphQLTypeReference(for: list.ofType)))"
        }

        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name

            // Map to built-in GraphQL types
            switch typeName {
            case "ID": return "GraphQLID"
            case "String": return "GraphQLString"
            case "Int": return "GraphQLInt"
            case "Float": return "GraphQLFloat"
            case "Boolean": return "GraphQLBoolean"
            default:
                // Reference to a custom type variable
                let varName = nameGenerator.swiftMemberName(for: typeName)
                return varName
            }
        }

        throw GeneratorError.unsupportedType("Unknown type: \(type)")
    }

    enum RootType {
        case query
        case mutation
        case subscription
    }

    enum ResolverTarget {
        case parent
        case query
        case mutation
        case subscription
    }
}
