import Foundation
import GraphQL

/// Generates the GraphQL schema builder function
package struct SchemaGenerator {
    let schema: GraphQLSchema
    let nameGenerator: SafeNameGenerator = .idiomatic

    package init(schema: GraphQLSchema) {
        self.schema = schema
    }

    package func generate() throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        /// Build a GraphQL schema with the provided resolvers
        public func buildGraphQLSchema(resolvers: GraphQLResolvers) throws -> GraphQLSchema {

        """

        // Generate type definitions for all object types
        let typeMap = schema.typeMap
        let objectTypes = typeMap.values.compactMap { $0 as? GraphQLObjectType }

        // Generate GraphQLObjectType definitions for non-root types
        for objectType in objectTypes {
            // Skip introspection types and root operation types
            if objectType.name.hasPrefix("__") ||
               objectType.name == "Query" ||
               objectType.name == "Mutation" ||
               objectType.name == "Subscription" {
                continue
            }

            output += try generateObjectTypeDefinition(for: objectType, resolvers: "resolvers")
            output += "\n"
        }

        // Generate enum type definitions
        let enumTypes = typeMap.values.compactMap { $0 as? GraphQLEnumType }
        for enumType in enumTypes {
            // Skip GraphQL internal enums
            if enumType.name.hasPrefix("__") {
                continue
            }

            output += try generateEnumTypeDefinition(for: enumType)
            output += "\n"
        }

        // Generate Query type
        if let queryType = schema.queryType {
            output += try generateQueryTypeDefinition(for: queryType, resolvers: "resolvers")
            output += "\n"
        }

        // Generate Mutation type if it exists
        if let mutationType = schema.mutationType {
            output += try generateMutationTypeDefinition(for: mutationType, resolvers: "resolvers")
            output += "\n"
        }

        // Build and return the schema
        output += """
            return try GraphQLSchema(
                query: queryType
        """

        if schema.mutationType != nil {
            output += ",\n        mutation: mutationType"
        }

        output += """

            )
        }

        """

        return output
    }

    private func generateObjectTypeDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Type"

        var output = """
            let \(varName) = try GraphQLObjectType(
                name: "\(type.name)",

        """

        if let description = type.description {
            output += """
                    description: \"\"\"
            \(description)
            \"\"\",

            """
        }

        output += """
                fields: [

        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            // For non-root types, only generate resolver callbacks for fields that return object types
            let needsResolver = isObjectType(field.type)

            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: type.name,
                resolvers: resolvers,
                isRootType: false,
                needsResolver: needsResolver
            )
        }

        output += """
                ]
            )

        """

        return output
    }

    private func generateEnumTypeDefinition(for type: GraphQLEnumType) throws -> String {
        let varName = nameGenerator.swiftMemberName(for: type.name) + "Type"

        var output = """
            let \(varName) = try GraphQLEnumType(
                name: "\(type.name)",

        """

        if let description = type.description {
            output += """
                    description: \"\"\"
            \(description)
            \"\"\",

            """
        }

        output += """
                values: [

        """

        for value in type.values {
            let safeCaseName = nameGenerator.swiftMemberName(for: value.name)
            output += """
                        "\(value.name)": GraphQLEnumValue(

            """

            if let description = value.description {
                output += """
                            value: \(safeCaseName),
                            description: \"\"\"\(description)\"\"\"

                """
            } else {
                output += """
                            value: Map.string("\(value.name)")

                """
            }

            output += """
                        ),

            """
        }

        output += """
                ]
            )

        """

        return output
    }

    private func generateQueryTypeDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        var output = """
            let queryType = try GraphQLObjectType(
                name: "Query",

        """

        if let description = type.description {
            output += """
                    description: \"\"\"
            \(description)
            \"\"\",

            """
        }

        output += """
                fields: [

        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: "Query",
                resolvers: resolvers,
                isRootType: true
            )
        }

        output += """
                ]
            )

        """

        return output
    }

    private func generateMutationTypeDefinition(for type: GraphQLObjectType, resolvers: String) throws -> String {
        var output = """
            let mutationType = try GraphQLObjectType(
                name: "Mutation",

        """

        if let description = type.description {
            output += """
                    description: \"\"\"
            \(description)
            \"\"\",

            """
        }

        output += """
                fields: [

        """

        // Generate fields
        let fields = try type.fields()
        for (fieldName, field) in fields {
            output += try generateFieldDefinition(
                fieldName: fieldName,
                field: field,
                parentTypeName: "Mutation",
                resolvers: resolvers,
                isRootType: true
            )
        }

        output += """
                ]
            )

        """

        return output
    }

    private func generateFieldDefinition(
        fieldName: String,
        field: GraphQLField,
        parentTypeName: String,
        resolvers: String,
        isRootType: Bool,
        needsResolver: Bool = true
    ) throws -> String {
        var output = """
                    "\(fieldName)": GraphQLField(
                        type: \(try graphQLTypeReference(for: field.type)),

        """

        if let description = field.description {
            output += """
                            description: \"\"\"
                \(description)
                \"\"\",

            """
        }

        // Add arguments if any
        if !field.args.isEmpty {
            output += """
                            args: [

            """

            for (argName, arg) in field.args {
                output += """
                                    "\(argName)": GraphQLArgument(
                                        type: \(try graphQLTypeReference(for: arg.type))

                """

                if let description = arg.description {
                    output += """
                                            , description: \"\"\"
                        \(description)
                        \"\"\"

                    """
                }

                output += """
                                    ),

                """
            }

            output += """
                            ],

            """
        }

        // Generate resolver function only if needed
        if needsResolver {
            output += try generateResolverCallback(
                fieldName: fieldName,
                field: field,
                parentTypeName: parentTypeName,
                resolvers: resolvers,
                isRootType: isRootType
            )
        }

        output += """
                    ),

        """

        return output
    }

    private func generateResolverCallback(
        fieldName: String,
        field: GraphQLField,
        parentTypeName: String,
        resolvers: String,
        isRootType: Bool
    ) throws -> String {
        let safeFieldName = nameGenerator.swiftMemberName(for: fieldName)

        var output = """
                        resolve: { source, args, context, _ in

        """

        // Build argument list
        var argsList: [String] = []

        if !isRootType {
            // For nested resolvers, first argument is the parent object
            let safeParentTypeName = nameGenerator.swiftTypeName(for: parentTypeName)
            output += """
                                guard let parent = source as? \(safeParentTypeName) else {
                                    throw GraphQLError(message: "Invalid source type for \(parentTypeName).\(fieldName)")
                                }

            """
            argsList.append("parent: parent")
        }

        // Add field arguments
        for (argName, arg) in field.args {
            let safeArgName = nameGenerator.swiftMemberName(for: argName)
            let swiftType = try swiftTypeName(for: arg.type, nameGenerator: nameGenerator)
            let conversionCode = try mapConversionCode(for: arg.type, valueName: "value", swiftType: swiftType)
            let isOptional = !(arg.type is GraphQLNonNull)

            // Extract value from Map based on type
            if isOptional {
                output += """
                                    let \(safeArgName): \(swiftType) = args["\(argName)"].map { try! \(conversionCode) }

                """
            } else {
                output += """
                                    let \(safeArgName): \(swiftType)
                                    if let value = args["\(argName)"] {
                                        \(safeArgName) = try \(conversionCode)
                                    } else {
                                        throw GraphQLError(message: "Required argument '\(argName)' is missing")
                                    }

                """
            }

            argsList.append("\(safeArgName): \(safeArgName)")
        }

        // Add context
        argsList.append("context: context as! ResolverContext")

        // Call the resolver
        let resolverMethodName: String
        if isRootType {
            resolverMethodName = safeFieldName
        } else {
            let parentName = nameGenerator.swiftMemberName(for: parentTypeName)
            let fieldNameCapitalized = safeFieldName.prefix(1).uppercased() + safeFieldName.dropFirst()
            resolverMethodName = "\(parentName)\(fieldNameCapitalized)"
        }

        output += """
                                return try await \(resolvers).\(resolverMethodName)(\(argsList.joined(separator: ", ")))
                            }

        """

        return output
    }

    /// Generate GraphQL type reference string (e.g., "GraphQLString", "GraphQLNonNull(GraphQLString)")
    private func graphQLTypeReference(for type: GraphQLType) throws -> String {
        if let nonNull = type as? GraphQLNonNull {
            return "GraphQLNonNull(\(try graphQLTypeReference(for: nonNull.ofType)))"
        }

        if let list = type as? GraphQLList {
            return "GraphQLList(\(try graphQLTypeReference(for: list.ofType)))"
        }

        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name

            // Map to built-in GraphQL types
            switch typeName {
            case "ID": return "GraphQLID"
            case "String": return "GraphQLString"
            case "Int": return "GraphQLInt"
            case "Float": return "GraphQLFloat"
            case "Boolean": return "GraphQLBoolean"
            default:
                // Reference to a custom type variable
                let varName = nameGenerator.swiftMemberName(for: typeName) + "Type"
                return varName
            }
        }

        throw GeneratorError.unsupportedType("Unknown type: \(type)")
    }

    /// Generate code to convert a Map value to a Swift type
    private func mapConversionCode(for type: GraphQLType, valueName: String, swiftType: String) throws -> String {
        // For non-null types, unwrap and convert
        if let nonNull = type as? GraphQLNonNull {
            let innerCode = try mapConversionCode(for: nonNull.ofType, valueName: valueName, swiftType: String(swiftType.dropLast()))
            return innerCode
        }

        // For list types, map over the array
        if let list = type as? GraphQLList {
            return "try \(valueName).arrayValue?.map { try \(try swiftTypeName(for: list.ofType, nameGenerator: nameGenerator))($0) }"
        }

        // For named types, convert based on scalar type
        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name

            switch typeName {
            case "ID", "String":
                return "\(valueName).string!"
            case "Int":
                return "\(valueName).int!"
            case "Float":
                return "\(valueName).double!"
            case "Boolean":
                return "\(valueName).bool!"
            default:
                // For custom types (enums, etc.), try to decode
                return "try \(swiftType)(\(valueName))"
            }
        }

        throw GeneratorError.unsupportedType("Unknown type: \(type)")
    }

    /// Check if a GraphQL type is an object type (not a scalar, enum, etc.)
    private func isObjectType(_ type: GraphQLType) -> Bool {
        // Unwrap NonNull and List
        if let nonNull = type as? GraphQLNonNull {
            return isObjectType(nonNull.ofType)
        }
        if let list = type as? GraphQLList {
            return isObjectType(list.ofType)
        }

        // Check if it's a named object type (not a scalar or enum)
        if let namedType = type as? GraphQLNamedType {
            let typeName = namedType.name
            // Built-in scalars are not object types
            if ["ID", "String", "Int", "Float", "Boolean"].contains(typeName) {
                return false
            }
            // Check if it's an object type (not an enum or scalar)
            return namedType is GraphQLObjectType
        }

        return false
    }
}
