import Foundation
import GraphQL

/// Generates resolver protocol from GraphQL schema
package struct ResolverGenerator {
    let schema: GraphQLSchema
    let nameGenerator: SafeNameGenerator = .idiomatic

    package init(schema: GraphQLSchema) {
        self.schema = schema
    }

    package func generate() throws -> String {
        var output = """
        // Generated by GraphQL Generator
        // DO NOT EDIT - This file is automatically generated

        import Foundation
        import GraphQL
        import GraphQLGeneratorRuntime

        /// Protocol defining all resolver methods for your GraphQL schema
        public protocol GraphQLResolvers: Sendable {

        """

        // Generate resolver methods for Query type
        if let queryType = schema.queryType {
            output += try generateResolverMethods(for: queryType, rootType: "Query")
        }

        // Generate resolver methods for Mutation type
        if let mutationType = schema.mutationType {
            output += try generateResolverMethods(for: mutationType, rootType: "Mutation")
        }

        // Generate resolver methods for nested fields
        let typeMap = schema.typeMap
        let objectTypes = typeMap.values.compactMap { $0 as? GraphQLObjectType }

        for objectType in objectTypes {
            // Skip introspection types and root operation types
            if objectType.name.hasPrefix("__") ||
               objectType.name == "Query" ||
               objectType.name == "Mutation" ||
               objectType.name == "Subscription" {
                continue
            }

            output += try generateNestedResolverMethods(for: objectType)
        }

        output += "}\n"

        return output
    }

    private func generateResolverMethods(for type: GraphQLObjectType, rootType: String) throws -> String {
        var output = ""

        output += "    // MARK: - \(rootType) Resolvers\n\n"

        let fields = try type.fields()
        for (fieldName, field) in fields {
            if let description = field.description {
                output += "    /// \(description)\n"
            }

            let returnType = try swiftTypeName(for: field.type, nameGenerator: nameGenerator)

            // Generate parameter list
            var params: [String] = []

            // Add arguments
            for (argName, arg) in field.args {
                let argType = try swiftTypeName(for: arg.type, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: ResolverContext")

            let paramString = params.joined(separator: ", ")

            output += "    func \(fieldName)(\(paramString)) async throws -> \(returnType)\n\n"
        }

        return output
    }

    private func generateNestedResolverMethods(for type: GraphQLObjectType) throws -> String {
        var output = ""
        let fields = try type.fields()

        // Only generate nested resolvers for fields that reference other object types
        let nestedFields = fields.filter { (_, field) in
            let unwrappedType = unwrapType(field.type)
            return unwrappedType is GraphQLObjectType && !(unwrappedType is GraphQLScalarType)
        }

        if nestedFields.isEmpty {
            return ""
        }

        output += "    // MARK: - \(type.name) Field Resolvers\n\n"

        for (fieldName, field) in nestedFields {
            if let description = field.description {
                output += "    /// \(description)\n"
            }

            let returnType = try swiftTypeName(for: field.type, nameGenerator: nameGenerator)

            // Parent parameter is the type itself
            var params: [String] = ["parent: \(type.name)"]

            // Add arguments if any
            for (argName, arg) in field.args {
                let argType = try swiftTypeName(for: arg.type, nameGenerator: nameGenerator)
                params.append("\(argName): \(argType)")
            }

            // Add context parameter
            params.append("context: ResolverContext")

            let paramString = params.joined(separator: ", ")

            output += "    func \(type.name.lowercased())\(fieldName.capitalized)(\(paramString)) async throws -> \(returnType)\n\n"
        }

        return output
    }

    /// Unwrap GraphQL type to get the base type
    private func unwrapType(_ type: GraphQLType) -> GraphQLType {
        if let nonNull = type as? GraphQLNonNull {
            return unwrapType(nonNull.ofType)
        }
        if let list = type as? GraphQLList {
            return unwrapType(list.ofType)
        }
        return type
    }
}
